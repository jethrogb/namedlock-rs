var searchIndex = {};
searchIndex['namedlock'] = {"items":[[0,"","namedlock","Namespaces for named locks.",null,null],[3,"LockSpaceGuard","","An RAII implementation of a \"scoped lock\" of a a LockSpace value. When this\nstructure is dropped (falls out of scope), the lock will be unlocked, and\nthe reference count to the key will be decreased by 1.",null,null],[3,"LockSpace","","A `LockSpace<K,V>` holds many `Mutex<V>`'s, keyed by `K`.",null,null],[4,"Cleanup","","",null,null],[13,"KeepUnused","","",0,null],[13,"AutoCleanup","","",0,null],[4,"LockSpaceRemoveResult","","",null,null],[13,"Success","","",1,null],[13,"NotFound","","",1,null],[13,"PoisonError","","",1,null],[13,"WouldBlock","","`remove()` would block.",1,null],[0,"lockresult","","A `Result` type very similar to `std::sync::LockResult`.",null,null],[3,"PoisonError","namedlock::lockresult","",null,null],[6,"LockResult","","A `Result` type very similar to `std::sync::LockResult`.",null,null],[11,"new","","",2,{"inputs":[{"name":"poisonerror"}],"output":{"name":"poisonerror"}}],[11,"fmt","","",2,{"inputs":[{"name":"poisonerror"},{"name":"formatter"}],"output":{"name":"result"}}],[0,"arcmutexguard","namedlock","Mutex guards that can outlive the Mutex.",null,null],[3,"ArcMutexGuard","namedlock::arcmutexguard","An RAII implementation of a \"scoped lock\" of a mutex. When this structure\nis dropped (falls out of scope), the lock will be unlocked, and the\nreference count to the Mutex will be decreased by 1.",null,null],[5,"arc_mutex_lock","","Acquires an `Arc<Mutex<_>>`, blocking the current thread until it is able to do so.",null,{"inputs":[{"name":"arc"}],"output":{"name":"lockresult"}}],[6,"Target","","",null,null],[11,"deref","","",3,{"inputs":[{"name":"arcmutexguard"}],"output":{"name":"t"}}],[11,"deref_mut","","",3,{"inputs":[{"name":"arcmutexguard"}],"output":{"name":"t"}}],[11,"drop","","",3,{"inputs":[{"name":"arcmutexguard"}],"output":null}],[6,"Target","namedlock","",null,null],[11,"deref","","",4,{"inputs":[{"name":"lockspaceguard"}],"output":{"name":"v"}}],[11,"deref_mut","","",4,{"inputs":[{"name":"lockspaceguard"}],"output":{"name":"v"}}],[11,"drop","","",4,{"inputs":[{"name":"lockspaceguard"}],"output":null}],[11,"clone","","",0,{"inputs":[{"name":"cleanup"}],"output":{"name":"cleanup"}}],[11,"eq","","",0,{"inputs":[{"name":"cleanup"},{"name":"cleanup"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"cleanup"},{"name":"cleanup"}],"output":{"name":"bool"}}],[11,"clone","","",5,{"inputs":[{"name":"lockspace"}],"output":{"name":"lockspace"}}],[11,"new","","Create a new LockSpace.",5,{"inputs":[{"name":"lockspace"},{"name":"cleanup"}],"output":{"name":"lockspace"}}],[11,"lock","","Find the object by `key`, or create it by calling `initial` if it does\nnot exist. Then, lock it and return a LockSpaceGuard over the object.\nOnce the guard is dropped, its object is unlocked, and if `AutoCleanup`\nis specified for this space, removed if this is the last use.",5,{"inputs":[{"name":"lockspace"},{"name":"q"},{"name":"c"}],"output":{"name":"lockresult"}}],[11,"with_lock","","Find the object by `key`, or create it by calling `initial` if it does\nnot exist. Then, call `f` on that object.",5,{"inputs":[{"name":"lockspace"},{"name":"q"},{"name":"c"},{"name":"f"}],"output":{"name":"lockresult"}}],[11,"try_remove","","Find the object by `key`, then delete it if it is not actively being\nused. If it is actually being used, `WouldBlock` will be returned.",5,{"inputs":[{"name":"lockspace"},{"name":"q"}],"output":{"name":"lockspaceremoveresult"}}],[14,"ahk_chain_borrow!","","See the `LockSpace` documentation on \"Key parameters\" for more information\non this macro.",null,null]],"paths":[[4,"Cleanup"],[4,"LockSpaceRemoveResult"],[3,"PoisonError"],[3,"ArcMutexGuard"],[3,"LockSpaceGuard"],[3,"LockSpace"]]};
initSearch(searchIndex);
